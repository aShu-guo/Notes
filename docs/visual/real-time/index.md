# 实时通信技术

对于前端开发者来说，实时与后端通信的技术主要分为3种，分别是：

- 定时轮询接口
- web socket
- event stream

## 定时轮询接口

顾名思义，前端通过setInterval或者RFA（requestFrameAnimation）每隔一段事件请求一次接口，底层是基于HTTP协议的，每次请求一次接口都需要重新构建一个http实例，导致前端性能损耗非常大。在请求间隔较短时，例如1秒请求10次接口，在运行半分钟左右可能会导致页面崩溃。

而且如果前端使用了底层为虚拟DOM的框架，例如Vue，底层需要通过diff算法比较新旧DOM进行patch，需要考虑接口请求的性能损耗能在多大的程度上影响patch逻辑的执行。

在开发中，通过自测发现使用setInterval轮询接口，并且使用v-for遍历渲染DOM时，即使为列表中每个item绑定唯一key，在接口请求速度快于虚拟DOM更新速度时会导致页面假死，并偶发页面崩溃问题。最重要的原因是单线程的JS在执行过程中，接口请求逻辑会阻塞渲染主线程。

总结可知，前端定时轮询接口的方案存在以下缺点：

- 前端页面存在性能问题
- 在请求速度足够快的情况下，偶发页面崩溃问题
- 后端服务器CPU占用率飙升，并且多个前端页面同时开时，可能会导致服务器宕机

那么，它存在这么多缺点，为什么还要使用呢？最重要的原因是对前后端现有代码侵入小，而且后端逻辑没有任何改动，只需要定制前端逻辑即可。

为了减少它的缺点带来的影响，经过探索，可以通过使用web worker技术减少接口请求对页面渲染的影响，但是如果需求中对时间精确度有要求，那么web
worker技术可能不适用。
## web socket

在 RFC 6455 规范中描述的 WebSocket 协议，提供了一种在浏览器和服务器之间建立持久连接来交换数据的方法。数据可以作为“数据包”在两个方向上传递，而无需中断连接也无需额外的
HTTP 请求。

支持客户端和服务端全双工通信，这意味着服务器和客户端都可以在任何时候发送消息。由于其全双工特性，适用于需要服务器和客户端双向实时交互的应用场景，如在线游戏、聊天应用等。

有其自己的独立协议（即 `ws://` 和 `wss://`），其中`wss://`是基于 TLS 的 WebSocket，类似于 HTTPS 是基于 TLS 的
HTTP。可以发送任意数据格式，如文本、二进制等。大多数现代浏览器都支持WebSocket。但是如果连接中断，客户端需要手动实现重连逻辑。

## event stream

event stream是一种支持服务端单向通信的技术，只支持半双工通信，只允许服务器向客户端发送消息。而且它使用的是标准HTTP协议。不像web
socket那样断连后需要客户端手动重连，它内置自动重连功能。如果连接断开，浏览器会尝试重新连接。消息通常是UTF-8编码的文本。在兼容性方面，虽然大多数现代浏览器都支持SSE，但例如Internet
Explorer和一些版本的Edge不支持。

在探索ChatGPT的使用过程中，我们发现GPT也是采用了流式数据返回的方式，即event stream

参考：

【1】[现代JavaScript教程-WebSocket](https://zh.javascript.info/websocket)

【2】[MDN-WebSocket](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket)
